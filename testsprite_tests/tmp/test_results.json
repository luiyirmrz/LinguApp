[
  {
    "projectId": "503a31f2-ad05-4fe2-9881-eec7e7067201",
    "testId": "8cbcdb81-d915-4a3f-98c5-6a6ea6e5cf07",
    "userId": "74a83438-f071-7004-4bf6-a77021e6a51b",
    "title": "TC001-test signin with valid and invalid credentials",
    "description": "Verify the /auth/signin endpoint correctly authenticates users with valid email and password, and rejects invalid credentials with appropriate error responses.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8081\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\n\ndef test_signin_with_valid_and_invalid_credentials():\n    signin_url = f\"{BASE_URL}/auth/signin\"\n\n    # Valid credentials example - should be replaced with real test user credentials if available\n    valid_email = \"testuser@example.com\"\n    valid_password = \"ValidPass123\"\n\n    # Invalid credentials examples\n    invalid_email = \"invaliduser@example.com\"\n    invalid_password = \"wrongpassword\"\n\n    # Test with valid credentials\n    valid_payload = {\n        \"email\": valid_email,\n        \"password\": valid_password\n    }\n    try:\n        res_valid = requests.post(signin_url, json=valid_payload, headers=HEADERS, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request with valid credentials failed: {e}\"\n\n    # On success, expect 200 OK and JSON with user and token\n    assert res_valid.status_code == 200, f\"Expected 200 for valid credentials but got {res_valid.status_code}\"\n    try:\n        json_data = res_valid.json()\n    except ValueError:\n        assert False, \"Response for valid credentials is not valid JSON\"\n\n    assert \"user\" in json_data, \"'user' field missing in valid signin response\"\n    assert isinstance(json_data[\"user\"], dict), \"'user' field is not an object\"\n    assert \"token\" in json_data, \"'token' field missing in valid signin response\"\n    assert isinstance(json_data[\"token\"], str) and len(json_data[\"token\"]) > 0, \"Invalid 'token' value\"\n\n    # Test with invalid credentials - invalid email, valid password\n    invalid_email_payload = {\n        \"email\": invalid_email,\n        \"password\": valid_password\n    }\n    try:\n        res_invalid_email = requests.post(signin_url, json=invalid_email_payload, headers=HEADERS, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request with invalid email failed: {e}\"\n\n    # Expected: not 200; usually 401 or 400; response with error message\n    assert res_invalid_email.status_code != 200, \"Signin succeeded with invalid email, expected failure\"\n\n    # Test with invalid credentials - valid email, invalid password\n    invalid_password_payload = {\n        \"email\": valid_email,\n        \"password\": invalid_password\n    }\n    try:\n        res_invalid_password = requests.post(signin_url, json=invalid_password_payload, headers=HEADERS, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request with invalid password failed: {e}\"\n\n    assert res_invalid_password.status_code != 200, \"Signin succeeded with invalid password, expected failure\"\n\n    # Optionally check error response structure or messages if present\n    for res in [res_invalid_email, res_invalid_password]:\n        try:\n            json_error = res.json()\n            assert isinstance(json_error, dict), \"Error response is not a JSON object\"\n            # May have error message or code - we don't have schema but check for typical fields\n            has_error_msg = any(key in json_error for key in [\"error\", \"message\", \"detail\"])\n            assert has_error_msg or len(json_error) == 0, \"Error response does not contain error info\"\n        except ValueError:\n            # Some servers may return empty body on error\n            pass\n\n\ntest_signin_with_valid_and_invalid_credentials()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 79, in <module>\n  File \"<string>\", line 30, in test_signin_with_valid_and_invalid_credentials\nAssertionError: Expected 200 for valid credentials but got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T10:54:12.746Z",
    "modified": "2025-09-06T10:55:03.019Z"
  },
  {
    "projectId": "503a31f2-ad05-4fe2-9881-eec7e7067201",
    "testId": "e70f83f6-aa9b-4e8c-ba85-5af5217d08a7",
    "userId": "74a83438-f071-7004-4bf6-a77021e6a51b",
    "title": "TC002-test signup with valid and invalid data",
    "description": "Verify the /auth/signup endpoint creates new user accounts with valid name, email, and password, and handles invalid or missing data properly.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8081\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\n\ndef test_signup_with_valid_and_invalid_data():\n    signup_url = f\"{BASE_URL}/auth/signup\"\n\n    # Valid data for successful signup\n    valid_user = {\n        \"name\": \"Test User\",\n        \"email\": f\"testuser_{uuid.uuid4()}@example.com\",\n        \"password\": \"ValidPass123\"\n    }\n\n    # Invalid test cases: missing fields or invalid data\n    invalid_users = [\n        {},  # completely empty\n        {\"name\": \"NoEmailUser\", \"password\": \"ValidPass123\"},  # missing email\n        {\"email\": \"no_name@example.com\", \"password\": \"ValidPass123\"},  # missing name\n        {\"name\": \"NoPasswordUser\", \"email\": \"nopassword@example.com\"},  # missing password\n        {\"name\": \"ShortPass\", \"email\": \"shortpass@example.com\", \"password\": \"short\"},  # password too short\n        {\"name\": \"InvalidEmail\", \"email\": \"invalidemail\", \"password\": \"ValidPass123\"},  # invalid email format\n    ]\n\n    user_id = None\n\n    try:\n        # Test valid signup\n        response = requests.post(signup_url, json=valid_user, headers=HEADERS, timeout=TIMEOUT)\n        assert response.status_code == 201 or response.status_code == 200, f\"Expected 200 or 201, got {response.status_code}\"\n        resp_json = response.json()\n        # Validate presence of user info, at least id, name, email\n        assert isinstance(resp_json, dict), \"Response is not a JSON object\"\n        assert \"id\" in resp_json or \"user\" in resp_json, \"Response missing 'id' or 'user'\"\n        # Capture user id for cleanup if available\n        if \"id\" in resp_json:\n            user_id = resp_json[\"id\"]\n        elif \"user\" in resp_json and \"id\" in resp_json[\"user\"]:\n            user_id = resp_json[\"user\"][\"id\"]\n        assert resp_json.get(\"name\", resp_json.get(\"user\", {}).get(\"name\")) == valid_user[\"name\"]\n        assert resp_json.get(\"email\", resp_json.get(\"user\", {}).get(\"email\")) == valid_user[\"email\"]\n\n        # Test invalid signups\n        for invalid_user in invalid_users:\n            resp = requests.post(signup_url, json=invalid_user, headers=HEADERS, timeout=TIMEOUT)\n            # We expect 4xx client error status codes for invalid data\n            assert 400 <= resp.status_code < 500, f\"Expected 4xx status code for invalid data, got {resp.status_code}\"\n    finally:\n        # If the API has a delete user endpoint, we would call it here to clean up the created user\n        # However, it is not specified in the PRD so this cleanup step is omitted\n        pass\n\n\ntest_signup_with_valid_and_invalid_data()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 58, in <module>\n  File \"<string>\", line 34, in test_signup_with_valid_and_invalid_data\nAssertionError: Expected 200 or 201, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T10:54:12.752Z",
    "modified": "2025-09-06T10:54:47.862Z"
  },
  {
    "projectId": "503a31f2-ad05-4fe2-9881-eec7e7067201",
    "testId": "453b60c8-8572-490d-971f-f672305af6c3",
    "userId": "74a83438-f071-7004-4bf6-a77021e6a51b",
    "title": "TC003-test get lessons with valid level and language parameters",
    "description": "Verify the /lessons GET endpoint returns the correct list of lessons filtered by CEFR level and language, and handles invalid or missing parameters gracefully.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8081\"\nTIMEOUT = 30\n\ndef test_get_lessons_with_valid_level_and_language_parameters():\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n\n    # Valid parameters\n    valid_level = \"B1\"\n    valid_language = \"English\"\n    params_valid = {\n        \"level\": valid_level,\n        \"language\": valid_language\n    }\n\n    try:\n        # Test with valid level and language parameters\n        response = requests.get(\n            f\"{BASE_URL}/lessons\",\n            headers=headers,\n            params=params_valid,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 200, f\"Expected status 200, got {response.status_code}\"\n        lessons = response.json()\n        assert isinstance(lessons, list), \"Expected response to be a list\"\n        # Validate that each lesson matches the filter criteria\n        for lesson in lessons:\n            assert isinstance(lesson, dict), \"Each lesson should be a dictionary\"\n            assert \"level\" in lesson, \"Lesson missing 'level' field\"\n            assert \"title\" in lesson, \"Lesson missing 'title' field\"\n            assert \"lessonId\" in lesson, \"Lesson missing 'lessonId' field\"\n            # Level should match requested level\n            assert lesson[\"level\"] == valid_level, f\"Lesson level {lesson['level']} does not match requested level {valid_level}\"\n        # It's possible language check not directly in lesson, no explicit language field in schema, skip that validation here\n\n        # Test with valid level only\n        params_level_only = {\"level\": valid_level}\n        response_level_only = requests.get(\n            f\"{BASE_URL}/lessons\",\n            headers=headers,\n            params=params_level_only,\n            timeout=TIMEOUT\n        )\n        assert response_level_only.status_code == 200\n        lessons_level_only = response_level_only.json()\n        assert isinstance(lessons_level_only, list)\n\n        # Test with valid language only\n        params_language_only = {\"language\": valid_language}\n        response_language_only = requests.get(\n            f\"{BASE_URL}/lessons\",\n            headers=headers,\n            params=params_language_only,\n            timeout=TIMEOUT\n        )\n        assert response_language_only.status_code == 200\n        lessons_language_only = response_language_only.json()\n        assert isinstance(lessons_language_only, list)\n\n        # Test with missing parameters (empty)\n        response_no_params = requests.get(\n            f\"{BASE_URL}/lessons\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert response_no_params.status_code == 200\n        lessons_no_params = response_no_params.json()\n        assert isinstance(lessons_no_params, list)\n\n        # Test with invalid level parameter\n        params_invalid_level = {\"level\": \"Z9\", \"language\": valid_language}\n        response_invalid_level = requests.get(\n            f\"{BASE_URL}/lessons\",\n            headers=headers,\n            params=params_invalid_level,\n            timeout=TIMEOUT\n        )\n        # Depending on API design, could either return 400 or 200 with empty list\n        assert response_invalid_level.status_code in (200, 400)\n        if response_invalid_level.status_code == 200:\n            lessons_invalid_level = response_invalid_level.json()\n            assert isinstance(lessons_invalid_level, list)\n        else:\n            # If error response, check error message json\n            try:\n                error_json = response_invalid_level.json()\n            except Exception:\n                error_json = None\n            assert error_json is not None, \"Error response missing JSON body\"\n\n        # Test with invalid language parameter (e.g. numeric)\n        params_invalid_language = {\"level\": valid_level, \"language\": \"1234$%\"}\n        response_invalid_language = requests.get(\n            f\"{BASE_URL}/lessons\",\n            headers=headers,\n            params=params_invalid_language,\n            timeout=TIMEOUT\n        )\n        assert response_invalid_language.status_code in (200, 400)\n        if response_invalid_language.status_code == 200:\n            lessons_invalid_language = response_invalid_language.json()\n            assert isinstance(lessons_invalid_language, list)\n        else:\n            try:\n                error_json_lang = response_invalid_language.json()\n            except Exception:\n                error_json_lang = None\n            assert error_json_lang is not None, \"Error response missing JSON body\"\n\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_get_lessons_with_valid_level_and_language_parameters()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 117, in <module>\n  File \"<string>\", line 27, in test_get_lessons_with_valid_level_and_language_parameters\nAssertionError: Expected status 200, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T10:54:12.757Z",
    "modified": "2025-09-06T10:55:04.455Z"
  },
  {
    "projectId": "503a31f2-ad05-4fe2-9881-eec7e7067201",
    "testId": "98a316c2-dbe8-40f3-b5db-2a854c83dfa1",
    "userId": "74a83438-f071-7004-4bf6-a77021e6a51b",
    "title": "TC004-test start lesson with valid and invalid lessonid",
    "description": "Verify the /lessons/{lessonId}/start POST endpoint starts the specified lesson successfully for valid lessonId, and returns appropriate errors for invalid or non-existent lessonId.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8081\"\nTIMEOUT = 30\n\ndef test_start_lesson_with_valid_and_invalid_lessonid():\n    # First, get a valid lessonId to test with\n    try:\n        lessons_resp = requests.get(f\"{BASE_URL}/lessons\", timeout=TIMEOUT)\n        lessons_resp.raise_for_status()\n        lessons = lessons_resp.json()\n        assert isinstance(lessons, list), \"Lessons response should be a list\"\n        assert len(lessons) > 0, \"No lessons available to test\"\n\n        valid_lesson_id = lessons[0].get(\"lessonId\")\n        assert valid_lesson_id and isinstance(valid_lesson_id, str), \"Invalid lessonId from lessons list\"\n\n        # Test starting lesson with valid lessonId\n        start_resp = requests.post(f\"{BASE_URL}/lessons/{valid_lesson_id}/start\", timeout=TIMEOUT)\n        assert start_resp.status_code == 200, f\"Expected 200 for valid lessonId, got {start_resp.status_code}\"\n\n        # Test starting lesson with an invalid format lessonId (e.g. empty string)\n        invalid_lesson_ids = [\"\", \"invalidLesson123\", \"00000000-0000-0000-0000-000000000000\"]\n        for invalid_id in invalid_lesson_ids:\n            resp = requests.post(f\"{BASE_URL}/lessons/{invalid_id}/start\", timeout=TIMEOUT)\n            # Expect error status codes (400 or 404) for invalid lessonId\n            assert resp.status_code in {400, 404}, f\"Expected 400 or 404 for invalid lessonId '{invalid_id}', got {resp.status_code}\"\n\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n    except AssertionError as e:\n        assert False, f\"Assertion failed: {e}\"\n\ntest_start_lesson_with_valid_and_invalid_lessonid()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 10, in test_start_lesson_with_valid_and_invalid_lessonid\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 500 Server Error: Internal Server Error for url: http://localhost:8081/lessons\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 34, in <module>\n  File \"<string>\", line 30, in test_start_lesson_with_valid_and_invalid_lessonid\nAssertionError: HTTP request failed: 500 Server Error: Internal Server Error for url: http://localhost:8081/lessons\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T10:54:12.762Z",
    "modified": "2025-09-06T10:54:47.851Z"
  },
  {
    "projectId": "503a31f2-ad05-4fe2-9881-eec7e7067201",
    "testId": "1d148c1c-1890-4602-8cf6-292d7fd44163",
    "userId": "74a83438-f071-7004-4bf6-a77021e6a51b",
    "title": "TC005-test get user gamification state",
    "description": "Verify the /gamification/state GET endpoint returns the current gamification state of the user including xp, level, streak, hearts, gems, and achievements.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8081\"\nTIMEOUT = 30  # seconds\n\ndef test_get_user_gamification_state():\n    url = f\"{BASE_URL}/gamification/state\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed: {e}\"\n\n    json_data = response.json()\n\n    assert isinstance(json_data, dict), \"Response is not a JSON object\"\n    # Validate presence and type of each required field according to schema\n    expected_fields = {\n        \"xp\": int,\n        \"level\": int,\n        \"streak\": int,\n        \"hearts\": int,\n        \"gems\": int,\n        \"achievements\": list\n    }\n    for field, expected_type in expected_fields.items():\n        assert field in json_data, f\"Missing field '{field}' in response\"\n        assert isinstance(json_data[field], expected_type), f\"Field '{field}' is not of type {expected_type.__name__}\"\n\n    # Validate achievements array items are strings\n    for achievement in json_data[\"achievements\"]:\n        assert isinstance(achievement, str), \"Achievement item is not a string\"\n\ntest_get_user_gamification_state()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 13, in test_get_user_gamification_state\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 500 Server Error: Internal Server Error for url: http://localhost:8081/gamification/state\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 37, in <module>\n  File \"<string>\", line 15, in test_get_user_gamification_state\nAssertionError: Request to http://localhost:8081/gamification/state failed: 500 Server Error: Internal Server Error for url: http://localhost:8081/gamification/state\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T10:54:12.767Z",
    "modified": "2025-09-06T10:54:54.627Z"
  },
  {
    "projectId": "503a31f2-ad05-4fe2-9881-eec7e7067201",
    "testId": "28b39c83-8b87-4206-9dff-a932ec890f52",
    "userId": "74a83438-f071-7004-4bf6-a77021e6a51b",
    "title": "TC006-test get user achievements list",
    "description": "Verify the /gamification/achievements GET endpoint returns a list of achievements with correct details and unlocked status for the user.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8081\"\nTIMEOUT = 30\n\ndef test_get_user_achievements_list():\n    url = f\"{BASE_URL}/gamification/achievements\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to /gamification/achievements failed: {e}\"\n\n    data = response.json()\n\n    assert isinstance(data, list), \"Response is not a list of achievements\"\n\n    # Each achievement object should have id (str), name (str), description (str), icon (str), unlocked (bool)\n    for achievement in data:\n        assert isinstance(achievement, dict), \"Achievement item is not a dictionary\"\n        assert \"id\" in achievement and isinstance(achievement[\"id\"], str), \"Achievement missing 'id' or not a string\"\n        assert \"name\" in achievement and isinstance(achievement[\"name\"], str), \"Achievement missing 'name' or not a string\"\n        assert \"description\" in achievement and isinstance(achievement[\"description\"], str), \"Achievement missing 'description' or not a string\"\n        assert \"icon\" in achievement and isinstance(achievement[\"icon\"], str), \"Achievement missing 'icon' or not a string\"\n        assert \"unlocked\" in achievement and isinstance(achievement[\"unlocked\"], bool), \"Achievement missing 'unlocked' or not a boolean\"\n\ntest_get_user_achievements_list()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 14, in test_get_user_achievements_list\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 500 Server Error: Internal Server Error for url: http://localhost:8081/gamification/achievements\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 31, in <module>\n  File \"<string>\", line 16, in test_get_user_achievements_list\nAssertionError: Request to /gamification/achievements failed: 500 Server Error: Internal Server Error for url: http://localhost:8081/gamification/achievements\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T10:54:12.773Z",
    "modified": "2025-09-06T10:54:46.142Z"
  },
  {
    "projectId": "503a31f2-ad05-4fe2-9881-eec7e7067201",
    "testId": "d69b230e-563d-4abd-9ba0-99db596e30fc",
    "userId": "74a83438-f071-7004-4bf6-a77021e6a51b",
    "title": "TC007-test get supported languages",
    "description": "Verify the /languages GET endpoint returns the complete list of supported languages with correct code, name, nativeName, and flag properties.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8081\"\nTIMEOUT = 30\n\ndef test_get_supported_languages():\n    url = f\"{BASE_URL}/languages\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"GET /languages request failed: {e}\"\n\n    try:\n        languages = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    assert isinstance(languages, list), \"Response should be a list\"\n\n    required_keys = {\"code\", \"name\", \"nativeName\", \"flag\"}\n    for lang in languages:\n        assert isinstance(lang, dict), \"Each language entry should be a dict\"\n        lang_keys = set(lang.keys())\n        assert required_keys.issubset(lang_keys), \\\n            f\"Language object missing required keys: {required_keys - lang_keys}\"\n        assert isinstance(lang[\"code\"], str) and lang[\"code\"], \"Language code must be a non-empty string\"\n        assert isinstance(lang[\"name\"], str) and lang[\"name\"], \"Language name must be a non-empty string\"\n        assert isinstance(lang[\"nativeName\"], str) and lang[\"nativeName\"], \"nativeName must be a non-empty string\"\n        assert isinstance(lang[\"flag\"], str) and lang[\"flag\"], \"Flag must be a non-empty string\"\n\n    # Validate the known supported languages are included and non-empty\n    expected_language_codes = {\"en\", \"es\", \"fr\", \"it\", \"hr\", \"zh\"}\n    found_codes = {lang[\"code\"] for lang in languages}\n    missing_codes = expected_language_codes - found_codes\n    assert not missing_codes, f\"Missing expected language codes: {missing_codes}\"\n\ntest_get_supported_languages()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 13, in test_get_supported_languages\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 500 Server Error: Internal Server Error for url: http://localhost:8081/languages\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 41, in <module>\n  File \"<string>\", line 15, in test_get_supported_languages\nAssertionError: GET /languages request failed: 500 Server Error: Internal Server Error for url: http://localhost:8081/languages\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T10:54:12.778Z",
    "modified": "2025-09-06T10:54:52.871Z"
  },
  {
    "projectId": "503a31f2-ad05-4fe2-9881-eec7e7067201",
    "testId": "8281bde7-75d9-4fdc-85d3-5c04c6a73e59",
    "userId": "74a83438-f071-7004-4bf6-a77021e6a51b",
    "title": "TC008-test update user language settings",
    "description": "Verify the /user/language-settings PUT endpoint updates the user's mainLanguage, targetLanguage, showTranslations, and showPhonetics settings correctly and handles invalid input.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8081\"\nTIMEOUT = 30\n\ndef test_update_user_language_settings():\n    url = f\"{BASE_URL}/user/language-settings\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Valid update payload\n    valid_payload = {\n        \"mainLanguage\": \"en\",\n        \"targetLanguage\": \"fr\",\n        \"showTranslations\": True,\n        \"showPhonetics\": False\n    }\n\n    try:\n        # Test valid update\n        response = requests.put(url, json=valid_payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected status 200, got {response.status_code}\"\n        resp_json = response.json()\n        for key, value in valid_payload.items():\n            assert key in resp_json, f\"Response missing '{key}'\"\n            assert resp_json[key] == value, f\"Expected {key}={value}, got {resp_json[key]}\"\n\n        # Invalid payloads to test error handling\n        invalid_payloads = [\n            {},  # empty\n            {\"mainLanguage\": 123, \"targetLanguage\": \"fr\", \"showTranslations\": True, \"showPhonetics\": False},  # mainLanguage wrong type\n            {\"mainLanguage\": \"en\", \"targetLanguage\": None, \"showTranslations\": True, \"showPhonetics\": False},  # targetLanguage null\n            {\"mainLanguage\": \"en\", \"targetLanguage\": \"fr\", \"showTranslations\": \"yes\", \"showPhonetics\": False},  # showTranslations wrong type\n            {\"mainLanguage\": \"en\", \"targetLanguage\": \"fr\", \"showTranslations\": True},  # missing showPhonetics\n        ]\n\n        for idx, inval_payload in enumerate(invalid_payloads, start=1):\n            r = requests.put(url, json=inval_payload, headers=headers, timeout=TIMEOUT)\n            assert r.status_code >= 400 and r.status_code < 500, f\"Invalid payload {idx} expected 4xx error, got {r.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_update_user_language_settings()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 44, in <module>\n  File \"<string>\", line 23, in test_update_user_language_settings\nAssertionError: Expected status 200, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T10:54:12.783Z",
    "modified": "2025-09-06T10:54:52.883Z"
  },
  {
    "projectId": "503a31f2-ad05-4fe2-9881-eec7e7067201",
    "testId": "4784d5aa-c47b-4467-9a27-992334b66cdf",
    "userId": "74a83438-f071-7004-4bf6-a77021e6a51b",
    "title": "TC009-test speech to text conversion",
    "description": "Verify the /speech/recognize POST endpoint correctly converts uploaded audio to text with confidence score, and handles invalid or missing audio data.",
    "code": "import requests\nfrom requests.exceptions import RequestException, Timeout\n\nBASE_URL = \"http://localhost:8081\"\nTIMEOUT = 30  # seconds\n\n\ndef test_speech_to_text_conversion():\n    url = f\"{BASE_URL}/speech/recognize\"\n    headers = {}\n    # Prepare a small valid WAV audio data (1-second silent audio)\n    valid_audio_content = (\n        b\"RIFF$\\x00\\x00\\x00WAVEfmt \\x10\\x00\\x00\\x00\\x01\\x00\\x01\\x00\"\n        b\"\\x40\\x1f\\x00\\x00\\x80>\"  # header part (partial)\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00data\\x00\\x00\\x00\\x00\"\n    )\n    files_valid = {'audio': ('test.wav', valid_audio_content, 'audio/wav')}\n\n    # Test 1: Valid audio file upload\n    try:\n        response = requests.post(url, files=files_valid, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected 200, got {response.status_code}\"\n        json_data = response.json()\n        assert \"text\" in json_data, \"Response JSON missing 'text' field\"\n        assert isinstance(json_data[\"text\"], str), \"'text' field is not a string\"\n        assert \"confidence\" in json_data, \"Response JSON missing 'confidence' field\"\n        confidence = json_data[\"confidence\"]\n        assert isinstance(confidence, (float, int)), \"'confidence' field is not a number\"\n        assert 0.0 <= confidence <= 1.0, \"'confidence' is out of range 0.0 to 1.0\"\n    except (RequestException, Timeout, AssertionError) as e:\n        raise AssertionError(f\"Valid audio upload failed: {e}\")\n\n    # Test 2: Invalid audio file upload (e.g., wrong file type or corrupted data)\n    files_invalid = {'audio': ('test.txt', b'This is not audio data', 'text/plain')}\n    try:\n        response = requests.post(url, files=files_invalid, headers=headers, timeout=TIMEOUT)\n        # Either service returns 4xx or 422 or 200 with error fields, handle accordingly\n        assert response.status_code != 500, \"Server error on invalid audio input\"\n        if response.status_code == 200:\n            json_data = response.json()\n            # Assuming invalid audio would not return text and confidence properly\n            text = json_data.get(\"text\", None)\n            confidence = json_data.get(\"confidence\", None)\n            assert (text is None or text == \"\") or (confidence is None or confidence == 0), \\\n                \"Invalid audio should not produce valid text or confidence\"\n        else:\n            assert 400 <= response.status_code < 500, \"Expected client error status for invalid audio\"\n    except (RequestException, Timeout, AssertionError) as e:\n        raise AssertionError(f\"Invalid audio upload handling failed: {e}\")\n\n    # Test 3: Missing audio file (empty multipart/form-data request)\n    try:\n        # Send no files part\n        response = requests.post(url, files={}, headers=headers, timeout=TIMEOUT)\n        # Expecting 4xx error due to missing required audio file\n        assert response.status_code != 500, \"Server error on missing audio input\"\n        assert 400 <= response.status_code < 500, \"Expected client error status for missing audio\"\n    except (RequestException, Timeout, AssertionError) as e:\n        raise AssertionError(f\"Missing audio handling failed: {e}\")\n\n\ntest_speech_to_text_conversion()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 22, in test_speech_to_text_conversion\nAssertionError: Expected 200, got 500\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 62, in <module>\n  File \"<string>\", line 31, in test_speech_to_text_conversion\nAssertionError: Valid audio upload failed: Expected 200, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T10:54:12.788Z",
    "modified": "2025-09-06T10:54:52.870Z"
  },
  {
    "projectId": "503a31f2-ad05-4fe2-9881-eec7e7067201",
    "testId": "c7105c27-8cad-4bc6-950f-ecc5340360ec",
    "userId": "74a83438-f071-7004-4bf6-a77021e6a51b",
    "title": "TC010-test text to speech synthesis",
    "description": "Verify the /speech/synthesize POST endpoint converts input text to speech audio URL for specified language and voice, and handles invalid or missing parameters.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8081\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\n\ndef test_text_to_speech_synthesis():\n    synthesize_url = f\"{BASE_URL}/speech/synthesize\"\n\n    # Valid test case: Provide all required fields with valid values\n    valid_payload = {\n        \"text\": \"Hello, world!\",\n        \"language\": \"en\",\n        \"voice\": \"default\"\n    }\n    try:\n        response = requests.post(synthesize_url, json=valid_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected 200, got {response.status_code}\"\n        json_resp = response.json()\n        assert \"audioUrl\" in json_resp, \"Response JSON missing 'audioUrl'\"\n        assert isinstance(json_resp[\"audioUrl\"], str) and json_resp[\"audioUrl\"].startswith(\"http\"), \\\n            \"'audioUrl' should be a valid URL string\"\n    except Exception as e:\n        assert False, f\"Exception during valid synthesis request: {e}\"\n\n    # Test missing 'text' parameter\n    missing_text_payload = {\n        \"language\": \"en\",\n        \"voice\": \"default\"\n    }\n    try:\n        response = requests.post(synthesize_url, json=missing_text_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert response.status_code >= 400, \"Expected client error status for missing 'text'\"\n    except Exception as e:\n        assert False, f\"Exception during missing 'text' request: {e}\"\n\n    # Test missing 'language' parameter\n    missing_language_payload = {\n        \"text\": \"Hello again\",\n        \"voice\": \"default\"\n    }\n    try:\n        response = requests.post(synthesize_url, json=missing_language_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert response.status_code >= 400, \"Expected client error status for missing 'language'\"\n    except Exception as e:\n        assert False, f\"Exception during missing 'language' request: {e}\"\n\n    # Test missing 'voice' parameter\n    missing_voice_payload = {\n        \"text\": \"Hello once more\",\n        \"language\": \"en\"\n    }\n    try:\n        response = requests.post(synthesize_url, json=missing_voice_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert response.status_code >= 400, \"Expected client error status for missing 'voice'\"\n    except Exception as e:\n        assert False, f\"Exception during missing 'voice' request: {e}\"\n\n    # Test invalid language code\n    invalid_language_payload = {\n        \"text\": \"Bonjour\",\n        \"language\": \"xx-invalid\",\n        \"voice\": \"default\"\n    }\n    try:\n        response = requests.post(synthesize_url, json=invalid_language_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert response.status_code >= 400, \"Expected client error status for invalid 'language' value\"\n    except Exception as e:\n        assert False, f\"Exception during invalid 'language' request: {e}\"\n\n    # Test invalid voice value\n    invalid_voice_payload = {\n        \"text\": \"Hola\",\n        \"language\": \"es\",\n        \"voice\": \"unknown-voice\"\n    }\n    try:\n        response = requests.post(synthesize_url, json=invalid_voice_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert response.status_code >= 400, \"Expected client error status for invalid 'voice' value\"\n    except Exception as e:\n        assert False, f\"Exception during invalid 'voice' request: {e}\"\n\n\ntest_text_to_speech_synthesis()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 19, in test_text_to_speech_synthesis\nAssertionError: Expected 200, got 500\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 85, in <module>\n  File \"<string>\", line 25, in test_text_to_speech_synthesis\nAssertionError: Exception during valid synthesis request: Expected 200, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T10:54:12.793Z",
    "modified": "2025-09-06T10:54:57.213Z"
  }
]
